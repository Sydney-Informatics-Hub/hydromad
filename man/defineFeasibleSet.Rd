% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/defineFeasibleSet.R
\name{defineFeasibleSet}
\alias{defineFeasibleSet}
\alias{defineFeasibleSet.hydromad}
\alias{defineFeasibleSet.default}
\title{Extract the feasible parameter sets meeting some criteria.}
\usage{
defineFeasibleSet(x, ...)

\method{defineFeasibleSet}{hydromad}(x, ..., thin = NA)

\method{defineFeasibleSet}{default}(
  x,
  model,
  objseq = rep(1, NROW(x)),
  frac.within = 0,
  within.rel = 0.01,
  within.abs = 0.1,
  groups = NULL,
  FUN = sum,
  target.coverage = 1,
  threshold = -Inf,
  glue.quantiles = c(0, 1),
  ...
)
}
\arguments{
\item{x}{in the \code{hydromad} method this is a \code{\link{hydromad}}
model object which has been run through either \code{\link{fitBySampling}}
or \code{\link{fitByDream}} to generate a large number of random parameter
sets with associated objective function scores.  In the \code{default}
method, the first argument (\code{x}) is a matrix of parameter values
corresponding to the objective function values \code{objseq}.}

\item{...}{extra arguments to the \code{hydromad} method are passed on to
the \code{default} method. Extra arguments to the \code{default} method will
result in an error.}

\item{thin}{interval between samples for results from DREAM.  As it is a
Markov Chain Monte Carlo method, the sequences should be thinned first to
remove autocorrelation and achieve an efficient sample of the parameter
distributions. The default thinning interval \code{NA} uses the empirical
autocorrelation.  See \code{window.mcmc}.}

\item{model}{the \code{hydromad} model object to be used to run simulations.
Does not apply to the \code{hydromad} method.}

\item{objseq}{objective function values corresponding to the parameter sets
\code{x}. This does not apply to the \code{hydromad} method, where it is
assumed that the objective function values have already been calculated.
Note that \code{objseq} can be omitted if not using the
\code{target.coverage} or \code{threshold} arguments (i.e. if just defining
an error criterion with \code{frac.within, within.rel, within.abs}), so the
original simulation run is not necessary.}

\item{frac.within, within.abs, within.rel}{model simulations are only retained
in the feasible set if some fraction \code{frac.within} of the simulated
values are within a fraction \code{within.rel} of the observed values OR
within an absolute difference of \code{within.abs} (typically mm/day).}

\item{groups, FUN}{\code{groups} is an optional grouping variable, of the
same length as the observed data in \code{model}, used to aggregate the
observed and fitted time series. The function \code{FUN} is applied to each
group. In this case, the error criteria \code{frac.within, within.rel,
within.abs} are evaluated on the aggregated values, not the raw time series.
Also \code{target.coverage} applies to the aggregated values.  Typically
\code{groups} would be generated by \code{\link{cut.Date}} (for regular time
periods) or \code{\link{eventseq}} (for events).  Note that the
\code{feasible.bounds} (e.g. for plotting) in this case will be an
aggregated time series, it will not correspond to the original time index.
Use \code{update} or \code{predict} to generate bounds on the original time
index.}

\item{target.coverage}{fraction of the observed values to be contained
within the overall ranges of simulated values (minimum and maximum on each
time step) from the feasible set of parameters. Note, this does not refer to
the \code{glue.quantiles} values, but to the overall maximum and minimum.
The simulated values can be within the tolerance limit of observed values
given by \code{within.abs} to count as coverage.}

\item{threshold}{value of the objective function (the objective function
used to generate \code{objseq}) used to define the feasible set: all
parameter sets above this threshold value will be kept.  Also this
\code{threshold} value is subtracted from the objective function values to
calculate weights when \code{glue.quantiles} is given. If left as
\code{-Inf}, it will be set to the minimum objective function value in the
final feasible set.}

\item{glue.quantiles}{if specified, these GLUE quantiles of the ensemble
simulations will be calculated and stored. They can be extracted with
\code{fitted} and shown in \code{xyplot}. The quantiles are calcualted using
the \code{\link[Hmisc]{wtd.quantile}} function, and weighted according to
\code{objseq} - \code{threshold}. If \code{glue.quantiles} is left as
\code{c(0,1)} then the overall minimum and maximum simulated values are
taken on each time step, which is faster.}
}
\value{
a modified version of \code{model}, with added elements
\code{feasible.set}, \code{feasible.scores}, \code{feasible.fitted},
\code{glue.quantiles} and \code{feasible.threshold}.  Can be passed to
\code{xyplot}, \code{fitted}, \code{predict}, \code{update}, \code{coef},
and \code{print}.
}
\description{
Extract the feasible (or \emph{behavioural}) parameter sets meeting some
criteria. These could be used as a feasible set or to estimate prediction
quantiles according to the GLUE (Generalised Likelihood Uncertainty
Estimation) method.
}
\examples{

data(Queanbeyan)
ts74 <- window(Queanbeyan, start = "1974-01-01", end = "1976-12-01")
mod <- hydromad(ts74, routing = "expuh", rfit = list("inverse", order = c(2, 1)))
mod <- update(mod,
  sma = "cwi",
  tw = c(0, 100), f = c(0, 8), loss = c(-0.1, 0.1)
)

## Calculate the set of simulations within 15\% error (or 1 mm/day) 90\% of time.
## In this case we do not need to calculate objective function values
## beforehand. For GLUE quantiles, however, need to give 'objective'.
psets <- parameterSets(coef(mod), samples = 300)
feas <- defineFeasibleSet(psets,
  model = mod,
  frac.within = 0.9, within.rel = 0.15, within.abs = 1
)

## How many of the 300 possible parameter sets were retained?
nrow(coef(feas, feasible.set = TRUE))

## View ranges of parameters in feasible set
feas

## Plot simulation bounds
xyplot(feas, feasible.bounds = TRUE, cut = 3)

## Generate set of simulations with NSE > 0.5, for GLUE.
## First, need to calculate objective function values:
fit <- fitBySampling(mod, samples = 300, objective = hmadstat("r.squared"))
## Calculate 5 percent and 95 percent GLUE quantiles (i.e. weighted).
fitglu <- defineFeasibleSet(fit,
  threshold = 0.5,
  glue.quantiles = c(0.05, 0.95)
)
## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
sim <- fitted(fitglu, feasible.bounds = TRUE)
head(sim)
mean((sim[, 1] < observed(fitglu) + 0.1) &
  (sim[, 2] > observed(fitglu) - 0.1))

## Or - keep adding parameter sets until we reach a target coverage:
## Calculate 5 percent and 95 percent GLUE quantiles (i.e. weighted).
fitglu <- defineFeasibleSet(fit,
  target.coverage = 0.9,
  glue.quantiles = c(0.05, 0.95)
)
## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
## (not to be confused with the target.coverage to define overall feasible set)
sim <- fitted(fitglu, feasible.bounds = TRUE)
mean((sim[, 1] < observed(fitglu) + 0.1) &
  (sim[, 2] > observed(fitglu) - 0.1))

## Plot simulated GLUE quantiles
xyplot(fitglu, feasible.bounds = TRUE, cut = 3)
xyplot(fitglu,
  feasible.bounds = TRUE, cut = 3,
  scales = list(y = list(log = TRUE))
)
## Summarise size of the simulation bounds: lower as fraction of upper
summary(coredata(sim[, 1] / sim[, 2]))

## Simulate on a new data period
newglu <- update(fitglu,
  newdata = window(Queanbeyan,
    start = "1980-01-01", end = "1982-01-01"
  ),
  glue.quantiles = c(0.05, 0.95)
)
## The new period is very dry, all model simulations overestimate flow.
xyplot(newglu, feasible.bounds = TRUE, cut = 3)
## Coverage of the GLUE quantile simulations (within 0.1 mm/day)
sim <- fitted(newglu, feasible.bounds = TRUE)
mean((sim[, 1] < observed(newglu) + 0.1) &
  (sim[, 2] > observed(newglu) - 0.1))
}
\seealso{
\code{\link{predict.hydromad}}, \code{update.hydromad},
\code{\link{fitBySampling}}, \code{\link{fitByDream}}
}
\author{
Felix Andrews \email{felix@nfrac.org}
}
\keyword{ts}
